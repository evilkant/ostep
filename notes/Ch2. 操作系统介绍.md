**程序运行时会发生什么？**

CPU会执行该程序的指令：
- 从内存获取（fetch）一条指令

- 解码（decode）指令

- 执行（execute）指令

如此循环往复，直到程序结束

fetch -> decode -> execute 这就是冯诺依曼提出的计算模型的基本概念。

我个人理解，如果把计算机比作一个庄园，操作系统就是这个庄园的管家——管家管理所有的资产（硬件资源），并负责给客人（应用程序）提供便捷的服务（系统调用）。

操作系统的绝活就是虚拟化：将物理资源（如处理器、内存或磁盘）转换为更通用更易于使用的虚拟形式（如进程、虚拟内存或文件系统）。

### 虚拟化
#### 虚拟化CPU
将单个CPU转换为看似无限数量的CPU，从而当许多程序看似同时运行，这就是所谓的虚拟化CPU（Virtualizing the CPU）。

#### 虚拟化内存
现代机器提供的物理内存（physical memory）模型非常简单，内存就是一个字节数组。

操作系统通过让每个进程访问自己私有的虚拟地址空间（virtual address space），然后以某种方式将虚拟地址映射到机器的物理内存地址上，营造了每个进程独享内存的假象。

### 并发
并发问题首先出现在操作系统本身（"The Unix Time-Sharing System"），随着现代多线程程序的流行，并发问题不再局限于操作系统之中。
```C
Counter++;
```
这样一条简单的语句，其执行并非原子性的，它需要3条指令：
1. 一条将计数器的值从内存加载到寄存器
2. 一条将其递增
3. 一条将其保存回内存

### 持久化
内存（DRAM）以易失（volatile）的方式存储数据，如果断电或系统崩溃，内存中的所有数据都会丢失。因此，我们需要硬件和软件来持久化数据。

在现代系统中，机械硬盘（也称磁盘）常被用来存储持久化数据，但是固态硬盘正逐渐取得领先地位。

不像操作系统为CPU和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚拟硬盘，相反，它假设用户经常需要共享文件中的信息。

### 目标

#### 抽象（Abstraction）
一个最基本的目标，是建立一些抽象，让系统方便和易于使用。
抽象使得编写大型程序成为可能，将其划分为小而且容易理解的部分，用C这样的高级语言编写程序不用考虑汇编，用汇编写代码不用考虑逻辑门，用逻辑门来构建处理器不用考虑晶体管。

#### 性能（Performance）
最小化操作系统的开销（minimize the overhead）

#### 保护（Protection）
因为我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序。让进程彼此隔离是保护的关键。

### 历史
#### 只是一组常用函数库
把低级IO处理代码封装起来作为API提供给程序员使用

#### 系统调用
通过添加一些特殊的硬件指令和硬件状态，区分用户模式和内核模式，让向操作系统过渡变为更正式的、受控的过程。
OS不再是提供Procedure Call，而是提供System Call。
系统调用和过程调用之间的关键区别在于，系统调用将控制移转到OS中，同时提高硬件特权级别（hardware privilege level）。

用户应用程序以所谓的用户模式运行，这意味着硬件限制了应用程序的功能。例如，以用户模式运行的应用程序通常不能发起对磁盘的IO请求，不能访问任何物理内存页或在网络上发送数据包。

在通过一个成为陷阱（trap）的特殊硬件指令发起系统调用时，硬件将控制转移到预先指定的陷阱处理程序（trap handler），并同时将特权级别提升到内核模式。在内核模式下，操作系统可以完全访问系统的硬件。当操作系统完成请求的服务时，它通过特殊的陷阱返回（return-from-trap）指令将控制权交还给用户。

#### 多道程序
IO设备很慢，在处理IO时让程序占着CPU，浪费了CPU时间，那么为什么不切到另一份工作并运行一段时间？

要支持多道程序和重叠运行，内存保护（memory protection）等问题变的重要。了解如何处理多道程序引入的并发（concurrency）问题也很关键。