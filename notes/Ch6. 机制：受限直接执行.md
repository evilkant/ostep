为了性能，必须允许应用程序的指令直接跑在物理CPU上，也就是所谓的直接执行（direct execution），和虚拟机执行相对应。

为了安全，处理器提供了受限制的用户模式（aka, baby mode）和不受限制的内核模式：应用程序跑在用户模式下，如果需要做任何危险动作（分配内存、读写文件），则需要通过系统调用拜托OS在内核模式下代劳。另外依赖硬件提供的时钟中断能力，OS确保自身总是能掌握控制权。这构成所谓的受限直接执行。

#### 系统调用

1. 应用进程执行系统调用
   1. 按规定在相应的寄存器或栈上填入系统调用号和调用参数
   2. 执行trap指令
2. 硬件切换内核模式，跳转到系统调用程序
   1. 把应用进程的寄存器上下文压到应用进程的内核中保存下来
   2. 切换处理器模式到内核模式
   3. 根据系统调用号查trap表，trap表是系统调用号到相应程序地址的一个映射表，跳到系统调用程序
3. 操作系统在系统调用例程的最后，通过return-from-trap指令把控制权交回
4. 硬件从内核栈恢复寄存器上下文、切回用户模式、继续运行应用进程

#### 进程切换

中断和系统调用非常类似——它们的机制几乎是一样的，只不过中断*一般*由硬件触发，系统调用是通过trap指令触发。

借助硬件在处理中断前后保存和恢复寄存器上下文的机制，非常容易实现上下文切换。

处理时钟中断时，OS把上一个运行的进程A的上下文保存到PCB里，然后重新设置内核栈指针来使用下一个进程B的内核栈，这样硬件在处理trap返回的时候就会恢复B的寄存器上下文，进而完成A到B的切换。