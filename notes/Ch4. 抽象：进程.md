#### 进程就是运行中的程序

程序运行背后，是CPU在不断地“取指令”-“解指令”-"执行指令"。

我的电脑只有一个CPU，怎么同时运行上百个程序的？

答案是OS安排进程们轮流使用CPU，每个进程用完一个时间片后就把CPU交给了下一个进程。

时间片轮转，就是OS提供的分配CPU资源的“机制”——具体每个时间片分配给哪个进程用，这是OS采用的“策略”。机制和策略分离，一般是好的设计。

#### 进程调度需要切换上下文

暂停进程A的执行，完整保留现场，切到下一个进程B，...，恢复A的现场，恢复A的执行

进程的现场就是进程的状态，就是所有进程会读写的数据存储

- 依赖的寄存器
- 使用的内存
- 打开的磁盘文件

把这些存储数据都存下来，现场就完整保留下来了

#### 进程状态

运行中->就绪：时间片用完了，回去排队吧

就绪->运行中：轮到你了，上来吧你

运行中->阻塞：卡壳了？下去吧你

阻塞->就绪：不卡壳了？排队去吧

#### 表示进程的数据结构

```c
struct proc{
    pid //唯一标识
    state //进程状态枚举值
    register_ctx //寄存器现场
    mem //内存
    files //打开的文件
}
```

Linux里叫做Process Control Block（PCB）



#### OS怎么拉起进程

首先，创建进程控制块。

然后，把程序代码和数据加载到内存，现代OS都用的懒加载（缺页异常时才加载）。

再其次，给程序的堆栈分配内存，如果需要的话，把main函数的参数（argc, argv）压栈，随后打开标准输入、标准输出和标准错误文件（UNIX里一切皆文件）。

最后，跳转到程序入口（main函数）执行。

#### 进程系统调用

fork, exec, wait三连

- fork拷贝当前进程（PCB）
- exec重新初始化进程
- wait等进程退出

为什么把fork和exec分开？为了在exec前做一些hack，比如实现输入输出的重定向

哦，还有kill



